// File: lib/services/auth_service.dart
   import 'package:appwrite/appwrite.dart';
   import 'package:appwrite/models.dart' as models;

   class AuthService {
     final Account account;

     AuthService({required this.account});

     Future<models.Token> sendOTP(String email) async {
       // Original AuthController.sendOTP used ID.unique() for userId.
       // This service method will require userId to be passed or generated if that's the desired pattern.
       // For now, let's assume userId is generated by the caller or a fixed system ID if appropriate.
       // Let's stick to what AuthController.sendOTP did: it generated a unique ID for the token.
       try {
         final result = await account.createEmailToken(
           userId: ID.unique(), // Consistent with original AuthController
           email: email,
         );
         return result;
       } on AppwriteException {
         rethrow;
       }
     }

     Future<models.Session> verifyOTP(String userId, String secret) async {
       try {
         final session = await account.updateMagicURLSession(
           userId: userId,
           secret: secret,
         );
         return session;
       } on AppwriteException {
         rethrow;
       }
     }

     Future<models.User?> getCurrentUserSession() async {
       try {
         final user = await account.get();
         return user;
       } on AppwriteException catch (e) {
         // A common code for "no session" or "unauthorized" is 401.
         // Allow specific exceptions to be handled by the caller.
         if (e.code == 401 || (e.message?.toLowerCase().contains("user (role: guests) missing scope (account)") ?? false) ) {
            // This specific message "user (role: guests) missing scope (account)" often indicates no active session.
            return null;
         }
         rethrow;
       }
     }

     Future<void> logout() async {
       try {
         await account.deleteSession(sessionId: 'current');
       } on AppwriteException {
         // Allow caller to handle, or log here if appropriate for a service.
         // For now, rethrow to let AuthController decide on UI feedback.
         rethrow;
       }
     }

     // Placeholder for actual account deletion logic.
     // The original `account.updateStatus()` in AuthController was incorrect.
     // True account deletion usually requires an Appwrite Function.
     Future<void> requestAccountDeletion() async {
       // This method would ideally call an Appwrite Function.
       // For now, it's a placeholder to show where such logic would go.
       // In a real scenario, this might make an HTTP request to a custom Appwrite function.
       print("AuthService: Account deletion requested. Implement via Appwrite Function.");
       // Simulate an action or throw UnimplementedError if preferred for this stage.
       throw UnimplementedError("Account deletion must be implemented via a secure Appwrite Function.");
     }
   }
