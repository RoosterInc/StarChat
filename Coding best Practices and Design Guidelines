# Flutter Development Guidelines for AI Agents

## ğŸ¯ CRITICAL: You are developing for a modern Flutter app with an established design system. Follow these guidelines religiously to maintain consistency, performance, and user experience quality.

---

## ğŸ“‹ MANDATORY REQUIREMENTS CHECKLIST

Before implementing ANY feature, ensure you understand and follow ALL of these requirements:

### âœ… **Design System Compliance**
- **ALWAYS** use the `modern_ui_system.dart` design system
- **NEVER** hardcode dimensions, colors, or spacing values
- **ALWAYS** use `DesignTokens` for spacing, colors, and sizing
- **ALWAYS** use responsive utilities for layouts

### âœ… **Responsive Design**
- **ALWAYS** use `ResponsiveUtils` for device-specific logic
- **NEVER** use raw `MediaQuery` - use design system utilities instead
- **ALWAYS** support mobile, tablet, and desktop layouts
- **ALWAYS** test in both portrait and landscape orientations

### âœ… **Performance Standards**
- **ALWAYS** use `const` constructors where possible
- **NEVER** use `Opacity` widget in animations - use `AnimatedOpacity`
- **ALWAYS** use `OptimizedListView` for lists with many items
- **ALWAYS** implement skeleton loading states instead of spinners

### âœ… **Accessibility Requirements**
- **ALWAYS** provide semantic labels for interactive elements
- **ALWAYS** ensure minimum touch target size of 44x44 pixels
- **ALWAYS** support screen readers with proper semantics
- **ALWAYS** maintain WCAG 2.1 AA contrast ratios

---

## ğŸ—ï¸ DESIGN SYSTEM USAGE

### **Spacing & Sizing**
```dart
// âœ… CORRECT - Use design tokens
Container(
  padding: DesignTokens.md(context).all,
  margin: DesignTokens.lg(context).vertical,
  width: ResponsiveUtils.fluidSize(context, min: 200, max: 400),
)

// âŒ WRONG - Never hardcode values
Container(
  padding: EdgeInsets.all(16),
  margin: EdgeInsets.symmetric(vertical: 24),
  width: 300,
)
```

### **Responsive Layouts**
```dart
// âœ… CORRECT - Use adaptive values
Widget build(BuildContext context) {
  return ResponsiveUtils.adaptiveValue(
    context,
    mobile: _buildMobileLayout(),
    tablet: _buildTabletLayout(), 
    desktop: _buildDesktopLayout(),
  );
}

// âŒ WRONG - Device-specific checks
if (MediaQuery.of(context).size.width > 600) {
  return _buildTabletLayout();
}
```

### **Colors & Theme**
```dart
// âœ… CORRECT - Use theme colors
Container(
  color: context.colorScheme.surface,
  child: Text(
    'Hello',
    style: context.textTheme.titleMedium?.copyWith(
      color: context.colorScheme.onSurface,
    ),
  ),
)

// âŒ WRONG - Hardcoded colors
Container(
  color: Colors.white,
  child: Text(
    'Hello',
    style: TextStyle(color: Colors.black, fontSize: 16),
  ),
)
```

---

## ğŸ¨ COMPONENT PATTERNS

### **Buttons - ALWAYS Use AnimatedButton**
```dart
// âœ… REQUIRED PATTERN
AnimatedButton(
  onPressed: () {
    // Your logic here
  },
  enableHaptics: true,
  child: Text('Submit'),
)

// âŒ FORBIDDEN - Don't use basic buttons
ElevatedButton(onPressed: () {}, child: Text('Submit'))
```

### **Cards - Use Glassmorphic Design**
```dart
// âœ… REQUIRED PATTERN
GlassmorphicCard(
  padding: DesignTokens.lg(context).all,
  onTap: () {
    MicroInteractions.selectionHaptic();
    // Your tap logic
  },
  child: YourContent(),
)

// âŒ FORBIDDEN - Basic cards
Card(child: YourContent())
```

### **Lists - Use Staggered Animations**
```dart
// âœ… REQUIRED PATTERN for lists with animations
StaggeredListView(
  children: items.map((item) => YourItemWidget(item)).toList(),
)

// âœ… REQUIRED PATTERN for performance-critical lists
OptimizedListView(
  itemCount: items.length,
  itemBuilder: (context, index) => YourItemWidget(items[index]),
)

// âŒ FORBIDDEN - Basic ListView for new features
ListView.builder(...)
```

### **Loading States - Use Skeleton Loaders**
```dart
// âœ… REQUIRED PATTERN
if (isLoading) {
  return Column(
    children: List.generate(5, (index) => 
      SkeletonLoader(
        height: 80,
        margin: DesignTokens.sm(context).bottom,
        borderRadius: BorderRadius.circular(DesignTokens.radiusMd(context)),
      ),
    ),
  );
}

// âŒ FORBIDDEN - Spinner loading
if (isLoading) return CircularProgressIndicator();
```

---

## ğŸš€ PERFORMANCE REQUIREMENTS

### **Widget Optimization**
```dart
// âœ… ALWAYS - Use const constructors
const Text('Hello World')
const Icon(Icons.star)
const SizedBox(height: 16)

// âœ… ALWAYS - Separate rebuild logic
class MyWidget extends StatelessWidget {
  const MyWidget({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return const _StaticContent(); // Const widget that won't rebuild
  }
}
```

### **Animation Best Practices**
```dart
// âœ… CORRECT - Use AnimatedBuilder for complex animations
AnimatedBuilder(
  animation: _controller,
  builder: (context, child) {
    return Transform.scale(
      scale: _animation.value,
      child: child,
    );
  },
  child: const ExpensiveWidget(), // Built once, reused
)

// âŒ WRONG - Rebuilding expensive widgets
AnimatedBuilder(
  animation: _controller,
  builder: (context, child) {
    return Transform.scale(
      scale: _animation.value,
      child: ExpensiveWidget(), // Rebuilt every frame!
    );
  },
)
```

---

## â™¿ ACCESSIBILITY REQUIREMENTS

### **Semantic Labels**
```dart
// âœ… REQUIRED - Always provide semantics
AccessibilityWrapper(
  semanticLabel: 'Add item to favorites',
  hint: 'Double tap to add this item to your favorites list',
  isButton: true,
  child: IconButton(
    icon: Icon(Icons.favorite),
    onPressed: () {},
  ),
)

// âŒ FORBIDDEN - Missing accessibility
IconButton(
  icon: Icon(Icons.favorite),
  onPressed: () {},
)
```

### **Touch Targets**
```dart
// âœ… CORRECT - Ensure minimum 44x44 touch targets
Container(
  width: math.max(44, actualWidth),
  height: math.max(44, actualHeight),
  child: YourButton(),
)
```

---

## ğŸ“± NAVIGATION PATTERNS

### **ALWAYS Use AdaptiveNavigation**
```dart
// âœ… REQUIRED PATTERN for main navigation
AdaptiveNavigation(
  selectedIndex: selectedIndex,
  onDestinationSelected: (index) => setState(() => selectedIndex = index),
  destinations: destinations,
  body: body,
  drawer: drawer, // Optional
)

// âŒ FORBIDDEN - Platform-specific navigation widgets
Scaffold(
  bottomNavigationBar: BottomNavigationBar(...),
)
```

---

## ğŸ¯ CODING STANDARDS

### **State Management (GetX)**
```dart
// âœ… CORRECT - Use reactive patterns
class MyController extends GetxController {
  final _isLoading = false.obs;
  bool get isLoading => _isLoading.value;
  
  final _items = <Item>[].obs;
  List<Item> get items => _items;
  
  Future<void> loadData() async {
    _isLoading.value = true;
    try {
      final data = await api.getData();
      _items.assignAll(data);
    } finally {
      _isLoading.value = false;
    }
  }
}

// âŒ WRONG - Direct state mutation
class MyController extends GetxController {
  bool isLoading = false;
  List<Item> items = [];
  
  Future<void> loadData() async {
    isLoading = true;
    update(); // Manual updates
  }
}
```

### **Error Handling**
```dart
// âœ… REQUIRED PATTERN
try {
  await someAsyncOperation();
} on AppwriteException catch (e) {
  logger.e('Specific error handling', error: e);
  _showErrorSnackbar('Operation failed', e.message);
} catch (e, stackTrace) {
  logger.e('General error', error: e, stackTrace: stackTrace);
  _showErrorSnackbar('Unexpected error', 'Please try again');
}
```

### **Null Safety**
```dart
// âœ… ALWAYS - Handle null safety properly
String? nullableValue = getValue();
if (nullableValue != null) {
  processValue(nullableValue);
}

// OR use null-aware operators
final result = nullableValue?.toUpperCase() ?? 'Default';

// âŒ FORBIDDEN - Force unwrapping without checks
String value = getValue()!; // Dangerous!
```

---

## ğŸ§ª TESTING REQUIREMENTS

### **ALWAYS Include Tests**
```dart
// âœ… REQUIRED - Widget tests for new components
testWidgets('MyWidget displays correct content', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      theme: MD3ThemeSystem.createTheme(
        seedColor: Colors.blue,
        brightness: Brightness.light,
      ),
      home: MyWidget(testData: testData),
    ),
  );
  
  expect(find.text('Expected Text'), findsOneWidget);
});

// âœ… REQUIRED - Unit tests for controllers
test('MyController loads data correctly', () async {
  final controller = MyController();
  await controller.loadData();
  
  expect(controller.items, isNotEmpty);
  expect(controller.isLoading, isFalse);
});
```

---

## ğŸ“– DOCUMENTATION REQUIREMENTS

### **Code Documentation**
```dart
/// Displays user profile information with edit capabilities.
/// 
/// This widget automatically adapts its layout based on screen size:
/// - Mobile: Single column layout
/// - Tablet: Two column layout  
/// - Desktop: Three column layout with sidebar
///
/// Example usage:
/// ```dart
/// UserProfileWidget(
///   user: currentUser,
///   onEdit: () => Navigator.push(...),
/// )
/// ```
class UserProfileWidget extends StatelessWidget {
  /// The user whose profile should be displayed.
  final User user;
  
  /// Callback invoked when user taps edit button.
  final VoidCallback? onEdit;
  
  const UserProfileWidget({
    Key? key,
    required this.user,
    this.onEdit,
  }) : super(key: key);
}
```

---

## ğŸš¨ CRITICAL ANTI-PATTERNS (NEVER DO THESE)

### âŒ **FORBIDDEN PRACTICES**
```dart
// NEVER hardcode dimensions
Container(width: 300, height: 200)

// NEVER use MediaQuery directly
MediaQuery.of(context).size.width > 600

// NEVER hardcode colors
Container(color: Colors.blue)

// NEVER use Opacity in animations
Opacity(opacity: _animation.value, child: child)

// NEVER ignore accessibility
GestureDetector(onTap: () {}, child: Icon(Icons.star))

// NEVER use basic loading indicators
CircularProgressIndicator()

// NEVER skip error handling
await riskyOperation(); // No try-catch!

// NEVER create widgets without const
Text('Hello') // Should be: const Text('Hello')

// NEVER use setState in GetX controllers
setState(() => counter++); // Use reactive variables!
```

---

## ğŸ”§ DEVELOPMENT WORKFLOW

### **Before Starting Implementation:**
1. âœ… Read and understand the feature requirements
2. âœ… Identify which existing components can be reused
3. âœ… Plan responsive behavior for mobile/tablet/desktop
4. âœ… Consider accessibility requirements
5. âœ… Plan error states and loading states
6. âœ… Identify performance optimization opportunities

### **During Implementation:**
1. âœ… Use design system components consistently
2. âœ… Add proper error handling and logging
3. âœ… Implement responsive layouts
4. âœ… Add accessibility features
5. âœ… Use const constructors everywhere possible
6. âœ… Add micro-interactions where appropriate

### **Before Completion:**
1. âœ… Test on multiple screen sizes
2. âœ… Test with screen reader enabled
3. âœ… Verify performance with profile mode
4. âœ… Add comprehensive documentation
5. âœ… Write unit and widget tests
6. âœ… Verify no hardcoded values exist

---

## ğŸ“‹ FINAL CHECKLIST

**Before submitting any code, verify:**

- [ ] All spacing uses `DesignTokens`
- [ ] All layouts are responsive using `ResponsiveUtils`
- [ ] All colors come from `context.colorScheme`
- [ ] All interactive elements have haptic feedback
- [ ] All buttons use `AnimatedButton`
- [ ] All cards use `GlassmorphicCard`
- [ ] All lists use `StaggeredListView` or `OptimizedListView`
- [ ] All loading states use `SkeletonLoader`
- [ ] All widgets have accessibility labels
- [ ] All async operations have error handling
- [ ] All widgets use `const` constructors where possible
- [ ] All features include comprehensive tests
- [ ] All code is properly documented

---

## ğŸ¯ SUCCESS METRICS

Your implementation is successful when:
- âœ… App renders perfectly on mobile, tablet, and desktop
- âœ… All animations are smooth (60fps)
- âœ… App passes accessibility audits
- âœ… No performance warnings in profile mode
- âœ… All tests pass with >90% code coverage
- âœ… Design system is used consistently throughout
- âœ… User interactions feel delightful and responsive

---

**Remember: Consistency is key. Every component you create should feel like it belongs to the same cohesive design system. When in doubt, refer to existing implementations in the codebase and follow the established patterns.**


CODE MAINTENANCE & STANDARDS
Naming Conventions (ENFORCE STRICTLY)

Classes: Use UpperCamelCase (e.g., UserProfileWidget, AuthenticationService)
Variables/Methods: Use lowerCamelCase (e.g., getUserData, isLoading)
Files: Use snake_case (e.g., user_profile_screen.dart, auth_service.dart)
Constants: Use lowerCamelCase with descriptive names (e.g., defaultPadding, primaryApiUrl)

Import Organization (ALWAYS APPLY)
dart// 1. Dart SDK imports
import 'dart:async';
import 'dart:convert';

// 2. Flutter imports
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// 3. External package imports
import 'package:http/http.dart' as http;
import 'package:provider/provider.dart';

// 4. Internal imports (use relative paths within lib/)
import '../models/user.dart';
import '../services/api_service.dart';
import 'components/custom_button.dart';
Static Analysis Requirements

ALWAYS ensure code passes flutter analyze without warnings
Use const constructors wherever possible
Declare return types explicitly
Avoid print() statements in production code

2. CODE REUSABILITY & DECOMPOSITION
Widget Decomposition Rules

Split widgets if build() method exceeds 100 lines
Extract repeated UI patterns into reusable widgets
Create small, focused widgets with single responsibilities

dart// âŒ BAD: Large monolithic widget
class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // 50+ lines of header code
          // 80+ lines of content code
          // 30+ lines of footer code
        ],
      ),
    );
  }
}

// âœ… GOOD: Decomposed widgets
class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          const ProfileHeader(),
          const ProfileContent(),
          const ProfileFooter(),
        ],
      ),
    );
  }
}
Common Widget Library

Create reusable components in lib/shared/widgets/
Build a consistent design system
Use composition over inheritance

3. EFFICIENT CODING PRACTICES
Build Method Optimization
dart// âŒ NEVER do heavy work in build()
@override
Widget build(BuildContext context) {
  final data = expensiveComputation(); // BAD!
  return Text(data);
}

// âœ… ALWAYS compute in initState() or use FutureBuilder
@override
Widget build(BuildContext context) {
  return FutureBuilder<String>(
    future: _computedData,
    builder: (context, snapshot) => Text(snapshot.data ?? ''),
  );
}
Const Usage (MANDATORY)

Use const constructors for static widgets
Add const to widget trees that don't change
Use const for static text, icons, and decorations

Smart Operators (USE EXTENSIVELY)
dart// Cascade operator for object initialization
final user = User()
  ..name = 'John'
  ..age = 30
  ..email = 'john@example.com';

// Spread operator for lists
final combined = [...existingItems, ...newItems];

// Null-aware operators
final name = user?.profile?.name ?? 'Unknown';
widget.onPressed?.call();
Logging Instead of Print
dart// âŒ NEVER use print()
print('Error occurred');

// âœ… ALWAYS use logger
import 'package:logger/logger.dart';
final logger = Logger();
logger.e('Error occurred', error, stackTrace);
4. CODE ORGANIZATION
Feature-First Structure (ALWAYS USE)
lib/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ authentication/
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ services/
â”‚   â”œâ”€â”€ profile/
â”‚   â””â”€â”€ shopping/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ widgets/
â”‚   â”œâ”€â”€ services/
â”‚   â””â”€â”€ utils/
â””â”€â”€ core/
    â”œâ”€â”€ constants/
    â”œâ”€â”€ themes/
    â””â”€â”€ config/
5. MEMORY MANAGEMENT & PERFORMANCE
Resource Disposal (CRITICAL)
dartclass _MyScreenState extends State<MyScreen> {
  StreamController? _controller;
  Timer? _timer;
  
  @override
  void dispose() {
    _controller?.close();
    _timer?.cancel();
    super.dispose();
  }
}
ListView Optimization
dart// âŒ NEVER create all items at once
ListView(
  children: items.map((item) => ItemWidget(item)).toList(),
)

// âœ… ALWAYS use builder for large lists
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) => ItemWidget(items[index]),
)
Image Optimization
dart// âœ… ALWAYS use cached network images
CachedNetworkImage(
  imageUrl: url,
  placeholder: (context, url) => const CircularProgressIndicator(),
  errorWidget: (context, url, error) => const Icon(Icons.error),
)
6. RESPONSIVE DESIGN (MANDATORY)
Screen Size Handling
dart// âœ… ALWAYS check screen constraints
Widget build(BuildContext context) {
  return LayoutBuilder(
    builder: (context, constraints) {
      if (constraints.maxWidth > 1200) {
        return DesktopLayout();
      } else if (constraints.maxWidth > 600) {
        return TabletLayout();
      }
      return MobileLayout();
    },
  );
}
7. STATE MANAGEMENT BEST PRACTICES
Efficient State Updates
dart// âœ… Use ValueNotifier for simple state
final counter = ValueNotifier<int>(0);

// âœ… Use ValueListenableBuilder
ValueListenableBuilder<int>(
  valueListenable: counter,
  builder: (context, value, child) => Text('$value'),
)
8. ERROR HANDLING & VALIDATION
Comprehensive Error Handling
dart// âœ… ALWAYS handle errors gracefully
try {
  final result = await apiCall();
  return Success(result);
} catch (e) {
  logger.e('API call failed', e);
  return Failure('Failed to load data');
}
9. ACCESSIBILITY & UX
Accessibility Requirements
dart// âœ… ALWAYS add semantic labels
Semantics(
  label: 'Add to cart button',
  child: IconButton(
    icon: Icon(Icons.add_shopping_cart),
    onPressed: addToCart,
  ),
)
10. PERFORMANCE MONITORING
Key Metrics to Consider

Widget rebuild frequency
Memory usage patterns
Frame rendering time
Network request efficiency

CODE REVIEW CHECKLIST
Before submitting or enhancing any Flutter code, ensure:

 All naming conventions followed
 Imports properly organized
 No print() statements
 All widgets use const where possible
 Large widgets decomposed
 Resources properly disposed
 ListView.builder used for dynamic lists
 Images cached appropriately
 Responsive design implemented
 Error handling in place
 Accessibility labels added
 No dead code or unused imports
